

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hls4ml.model.optimizer.passes package &mdash; hls4ml 1.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/sphinx_contributors.css?v=f079e67e" />

  
    <link rel="shortcut icon" href="../_static/hls4ml_logo.svg"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=fc837d61"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="hls4ml.optimization package" href="hls4ml.optimization.html" />
    <link rel="prev" title="hls4ml.model.optimizer package" href="hls4ml.model.optimizer.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../index.html">
            
              <img src="../_static/hls4ml_logo_navbar.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/status.html">Status and Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/setup.html">Setup and Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro/reference.html">Citation, Acknowledgments, and Contributors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/concepts.html">Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/configuration.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/command.html">Command Line Interface (deprecated)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/serialization.html">Saving/Loading hls4ml models</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Frontends</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../frontend/keras.html">Keras and its quantized variants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend/pytorch.html">PyTorch and Brevitas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../frontend/qonnx.html">ONNX and QONNX</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Backends</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../backend/vitis.html">Vivado/Vitis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backend/accelerator.html">VivadoAccelerator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backend/oneapi.html">oneAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backend/catapult.html">Catapult</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backend/quartus.html">Quartus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../backend/sr.html">SymbolicExpression</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../advanced/profiling.html">Profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/auto.html">Automatic precision inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/hgq.html">High Granularity Quantization (HGQ2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/da.html">Distributed Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/precision.html">Model-wise Precision Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/fifo_depth.html">FIFO Buffer Depth Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/extension.html">Extension API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/model_optimization.html">Hardware-aware Optimization API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/bramfactor.html">Loading weights from external BRAM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ir/ir.html">Internal representation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ir/modelgraph.html">ModelGraph Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ir/multimodelgraph.html">MultiModelGraph Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ir/flows.html">Optimizer Passes and Flows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ir/attributes.html">Layer attributes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Autogenerated API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="hls4ml.backends.html">hls4ml.backends package</a></li>
<li class="toctree-l1"><a class="reference internal" href="hls4ml.converters.html">hls4ml.converters package</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="hls4ml.model.html">hls4ml.model package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="hls4ml.model.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model.attributes">hls4ml.model.attributes module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model.graph">hls4ml.model.graph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model.layers">hls4ml.model.layers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#hls4ml-model-profiling-module">hls4ml.model.profiling module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model.quantizers">hls4ml.model.quantizers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model.types">hls4ml.model.types module</a></li>
<li class="toctree-l2"><a class="reference internal" href="hls4ml.model.html#module-hls4ml.model">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="hls4ml.optimization.html">hls4ml.optimization package</a></li>
<li class="toctree-l1"><a class="reference internal" href="hls4ml.report.html">hls4ml.report package</a></li>
<li class="toctree-l1"><a class="reference internal" href="hls4ml.utils.html">hls4ml.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="hls4ml.writer.html">hls4ml.writer package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">hls4ml</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="hls4ml.model.html">hls4ml.model package</a></li>
          <li class="breadcrumb-item"><a href="hls4ml.model.optimizer.html">hls4ml.model.optimizer package</a></li>
      <li class="breadcrumb-item active">hls4ml.model.optimizer.passes package</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/fastmachinelearning/hls4ml/blob/main/docs/autodoc/hls4ml.model.optimizer.passes.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="hls4ml-model-optimizer-passes-package">
<h1>hls4ml.model.optimizer.passes package<a class="headerlink" href="#hls4ml-model-optimizer-passes-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-hls4ml.model.optimizer.passes.batchnorm_opt">
<span id="hls4ml-model-optimizer-passes-batchnorm-opt-module"></span><h2>hls4ml.model.optimizer.passes.batchnorm_opt module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.batchnorm_opt" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.batchnorm_opt.</span></span><span class="sig-name descname"><span class="pre">BatchNormOnnxConstantParameters</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Remove Constant from the BatchNormalization node parameters (but not input[0])</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.BatchNormOnnxConstantParameters.transform" title="Link to this definition"></a></dt>
<dd><p>Remove Constant from the BatchNormalization node parameters (but not input[0])</p>
<p>TODO:  Currently the quantizers are not actually used by the underlying layer.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.batchnorm_opt.</span></span><span class="sig-name descname"><span class="pre">ConstantBatchNormFusion</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Merge BatchNorm into Const (after parameters have already been merged in BatchNormalization)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.ConstantBatchNormFusion.transform" title="Link to this definition"></a></dt>
<dd><p>Remove the batch norm</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.batchnorm_opt.</span></span><span class="sig-name descname"><span class="pre">FuseConsecutiveBatchNormalization</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>OptimizerPass to merge consecutive BatchNormalization layers, only if the earlier one does not have the output type
specified. There is a further check on the compatibility to merge: except in cases when merging a scale of 1 or a
bias of 0, this does not merge when both scales or both biases are quantized.</p>
<p>Note:  Consider restricting this to ApplyAlpha.  Batch Normalization-style quantization seems to be ignored.</p>
<p>Note:  This optimizer may not be safe if weights are updateable, in particular if a scale can go from ones to other
values or if a bias can go from zeros to other values.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.FuseConsecutiveBatchNormalization.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.batchnorm_opt.</span></span><span class="sig-name descname"><span class="pre">RemoveNopBatchNormalization</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>OptimizerPass to remove batch normalizations that do nothing (scale 1, bias 0)</p>
<p>Note:  This optimizer may not be safe if weights are updateable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.batchnorm_opt.RemoveNopBatchNormalization.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.bipolar_quant_opt">
<span id="hls4ml-model-optimizer-passes-bipolar-quant-opt-module"></span><h2>hls4ml.model.optimizer.passes.bipolar_quant_opt module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.bipolar_quant_opt" title="Link to this heading"></a></h2>
<p>This file includes optimizations related to BipolarQuant nodes.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bipolar_quant_opt.</span></span><span class="sig-name descname"><span class="pre">BipolarQuantConstantParameters</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Remove Constant from the BipolarQuant node parameters (but not input[0])</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantConstantParameters.transform" title="Link to this definition"></a></dt>
<dd><p>Remove Constant from the BipolarQuant node parameters (but not input[0])</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bipolar_quant_opt.</span></span><span class="sig-name descname"><span class="pre">BipolarQuantToActivation</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is 1. It is a a 1:1 transformation of a BipolarQuant to an Activation.
This is not called when the input is constant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToActivation.transform" title="Link to this definition"></a></dt>
<dd><p>Change BipolarQuant node to Activation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bipolar_quant_opt.</span></span><span class="sig-name descname"><span class="pre">BipolarQuantToAlphaActivationAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is not 1. It is a a 1:3 transformation of
a BipolarQuant to an ApplyAlpha (to scale), Activation, ApplyAlpha (to rescale).
Since there is no zero offset, the initial ApplyAlpha has no effect, so it is omitted.</p>
<p>NOTE:  It needs to be scheduled after BipolarQuantToActivation (or we need to make the match criteria stricter)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.BipolarQuantToAlphaActivationAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Change quant node to ApplyAlhpa, Activation, ApplyAlpha</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bipolar_quant_opt.</span></span><span class="sig-name descname"><span class="pre">ConstBipolarQuantToConstAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is not 1. It is a a 1:3 transformation of
a BipolarQuant to an ApplyAlpha (to scale), Activation, ApplyAlpho (to unscale), but an input
consts allows for optimization, so the ApplyAlpha (to scale), Activation are
optimized away right away.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.ConstBipolarQuantToConstAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Change Constant + Quant node to Constant, ApplyAlpha</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bipolar_quant_opt.</span></span><span class="sig-name descname"><span class="pre">FuseBipolarQuantWithConstant</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is 1 and the input is a constant</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bipolar_quant_opt.FuseBipolarQuantWithConstant.transform" title="Link to this definition"></a></dt>
<dd><p>Fuse BipolarQuant with Constant.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.bit_exact">
<span id="hls4ml-model-optimizer-passes-bit-exact-module"></span><h2>hls4ml.model.optimizer.passes.bit_exact module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.bit_exact" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.BitExact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">BitExact</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.BitExact" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.ModelOptimizerPass" title="hls4ml.model.optimizer.optimizer.ModelOptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelOptimizerPass</span></code></a></p>
<p>Model-wide bitwidth flow to ensure bit-exactness. Triggered by the presence of FixedPointQuantizer for now.
On the high level:
1. (forward flow) Starting from the model input, forward flow down the required bitwidth and shrink
FixedQuantizer bits when possible. Register the generated bw by each layer as “produced_kif”
2. (backward flow) For each layer, find the maximum bitwidth it can handle (till which point more bits makes no sense)
For example, a ap_fixed&lt;8,4&gt; in the downstream has won’t take advantage of &gt;4 fractional bits on the input.
3. (combine) Use the “minimal” of the produced and requested bitwidths on each layer</p>
<p>In all cases, the process is (supposed to be) bit-exact. Both forward and backward flows use quantized
interval arithmetic to determine the bitwidths semi-symbolically. BW&gt;=128 are unhandled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.BitExact.has_fixed_quantizer">
<span class="sig-name descname"><span class="pre">has_fixed_quantizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><span class="pre">ModelGraph</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.BitExact.has_fixed_quantizer" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.BitExact.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><span class="pre">ModelGraph</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.BitExact.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">FixInputPrecision</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.FixInputPrecision.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.default_register_precision">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">default_register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.default_register_precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_input_kifs">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_input_kifs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_input_kifs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_input_layers">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_input_layers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_input_layers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_input_shapes">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_input_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_input_shapes" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_output_layers">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_output_layers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_output_layers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_output_layers_and_quantizers">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_output_layers_and_quantizers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantizers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer" title="hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer"><span class="pre">FixedPointQuantizer</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_output_layers_and_quantizers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.get_output_shape">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">get_output_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.get_output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.im2col">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">im2col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.im2col" title="Link to this definition"></a></dt>
<dd><p>im2col for multidimensional arrays. Assumes Channel Last format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_size</strong> (<em>Sequence</em><em>[</em><em>int</em><em>]</em>) – The size of the kernel, in the form (<a href="#id1"><span class="problematic" id="id2">*</span></a>kernel_shape, ch_in, ch_out).</p></li>
<li><p><strong>*arrs</strong> (<em>np.ndarray</em>) – The input arrays to be transformed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed arrays.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.kif_arrs_to_ints">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">kif_arrs_to_ints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.kif_arrs_to_ints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.pad_arrs">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">pad_arrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_val</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.pad_arrs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.produce_kif">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">produce_kif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_reset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.produce_kif" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.r_im2col">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">r_im2col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.r_im2col" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.register_precision">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.register_precision" title="Link to this definition"></a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Activation" title="hls4ml.model.layers.Activation"><span class="pre">Activation</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Softmax" title="hls4ml.model.layers.Softmax"><span class="pre">Softmax</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT" title="hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT"><span class="pre">UnaryLUT</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling1D" title="hls4ml.model.layers.Pooling1D"><span class="pre">Pooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling2D" title="hls4ml.model.layers.Pooling2D"><span class="pre">Pooling2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling1D" title="hls4ml.model.layers.GlobalPooling1D"><span class="pre">GlobalPooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling2D" title="hls4ml.model.layers.GlobalPooling2D"><span class="pre">GlobalPooling2D</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling1D" title="hls4ml.model.layers.Pooling1D"><span class="pre">Pooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling2D" title="hls4ml.model.layers.Pooling2D"><span class="pre">Pooling2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling1D" title="hls4ml.model.layers.GlobalPooling1D"><span class="pre">GlobalPooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling2D" title="hls4ml.model.layers.GlobalPooling2D"><span class="pre">GlobalPooling2D</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling1D" title="hls4ml.model.layers.Pooling1D"><span class="pre">Pooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling2D" title="hls4ml.model.layers.Pooling2D"><span class="pre">Pooling2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling1D" title="hls4ml.model.layers.GlobalPooling1D"><span class="pre">GlobalPooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling2D" title="hls4ml.model.layers.GlobalPooling2D"><span class="pre">GlobalPooling2D</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling1D" title="hls4ml.model.layers.Pooling1D"><span class="pre">Pooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Pooling2D" title="hls4ml.model.layers.Pooling2D"><span class="pre">Pooling2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling1D" title="hls4ml.model.layers.GlobalPooling1D"><span class="pre">GlobalPooling1D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.GlobalPooling2D" title="hls4ml.model.layers.GlobalPooling2D"><span class="pre">GlobalPooling2D</span></a></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">register_precision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.ParametrizedActivation" title="hls4ml.model.layers.ParametrizedActivation"><span class="pre">ParametrizedActivation</span></a></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.request_kif">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">request_kif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.request_kif" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.requested_by_non_saturating_quantizer">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">requested_by_non_saturating_quantizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.requested_by_non_saturating_quantizer" title="Link to this definition"></a></dt>
<dd><p>Check if the current requested kif is from a quantizer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>layer</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The layer to check.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if requested by a non-saturating quantizer, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.requested_kif">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">requested_kif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int16</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.requested_kif" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.stride_arrs">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">stride_arrs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">arrs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.stride_arrs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bit_exact.to_hls4ml_fixed">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bit_exact.</span></span><span class="sig-name descname"><span class="pre">to_hls4ml_fixed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bit_exact.to_hls4ml_fixed" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.bn_fuse">
<span id="hls4ml-model-optimizer-passes-bn-fuse-module"></span><h2>hls4ml.model.optimizer.passes.bn_fuse module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.bn_fuse" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.bn_fuse.</span></span><span class="sig-name descname"><span class="pre">FuseBatchNormalization</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>OptimizerPass to merge a BatchNormalization layer with Dense or Conv layer, only if the Dense or Conv layer does not
have the output type specified. There is a further check on the compatibility to merge: except in cases when merging a
weight/scale of 1 or a bias of 0, this optimizer does not merge nodes when both the weight and scale or both biases
are quantized.</p>
<p>Note:  Consider restricting this to ApplyAlpha.  Batch Normalization quantization seems to be ignored.</p>
<p>Note:  This optimizer may not be safe if weights are updateable. May need to turn off.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.bn_fuse.FuseBatchNormalization.transform" title="Link to this definition"></a></dt>
<dd><p>Fuse weight and bias of Dense/Conv1D/Conv2D layer with BN values.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.conv_to_convxd">
<span id="hls4ml-model-optimizer-passes-conv-to-convxd-module"></span><h2>hls4ml.model.optimizer.passes.conv_to_convxd module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.conv_to_convxd" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.conv_to_convxd.</span></span><span class="sig-name descname"><span class="pre">ConvToConvXD</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert Conv with constant to a Conv1D or Conv2D layer</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_convxd.ConvToConvXD.transform" title="Link to this definition"></a></dt>
<dd><p>Convert Conv with constant to a Conv1D or Conv2D layer</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd">
<span id="hls4ml-model-optimizer-passes-conv-to-depthwiseconvxd-module"></span><h2>hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.</span></span><span class="sig-name descname"><span class="pre">ConvToDepthwiseConvXD</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert Conv with constant to a DepthwiseConv1D or DepthwiseConv2D layer</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.conv_to_depthwiseconvxd.ConvToDepthwiseConvXD.transform" title="Link to this definition"></a></dt>
<dd><p>Convert Conv with constant to a DepthwiseConv1D or DepthwiseConv2D layer</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.convert_to_channels_last">
<span id="hls4ml-model-optimizer-passes-convert-to-channels-last-module"></span><h2>hls4ml.model.optimizer.passes.convert_to_channels_last module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.convert_to_channels_last" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.convert_to_channels_last.</span></span><span class="sig-name descname"><span class="pre">ChannelsLastConverter</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Converts a model from channels_first to channels_last data format by transposing the weights of relevant layers
and adding a transpose layer for the inputs and outputs, if necessary</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.ChannelsLastConverter.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.convert_to_channels_last.</span></span><span class="sig-name descname"><span class="pre">RemoveTransposeBeforeFlatten</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>After the channels last conversion, model may have a sequence: Transpose -&gt; Flatten -&gt; Dense.
In this case we can remove the expensive transpose and instead transpose the weights of the Dense layer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.convert_to_channels_last.RemoveTransposeBeforeFlatten.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.expand_layer_group">
<span id="hls4ml-model-optimizer-passes-expand-layer-group-module"></span><h2>hls4ml.model.optimizer.passes.expand_layer_group module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.expand_layer_group" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.expand_layer_group.</span></span><span class="sig-name descname"><span class="pre">ExpandLayerGroup</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Expands LayerGroup (a nested model) into the parent model.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_layer_group.ExpandLayerGroup.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.expand_time_distributed">
<span id="hls4ml-model-optimizer-passes-expand-time-distributed-module"></span><h2>hls4ml.model.optimizer.passes.expand_time_distributed module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.expand_time_distributed" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.expand_time_distributed.</span></span><span class="sig-name descname"><span class="pre">ExpandTimeDistributed</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Expands TimeDistributed’s wrapped layer into the graph and inserts a marker at the end.</p>
<dl class="simple">
<dt>For example, the layer defined as:</dt><dd><p>TimeDistributed(Dense(…))</p>
</dd>
<dt>will be expanded to:</dt><dd><p>TimeDistributed(…)
Dense(…)
TimeDistributed(…)</p>
</dd>
</dl>
<p>the latter TimeDistributed serving as a marker of the end of the block and it will have “_end” appended to its name.</p>
<p>Handling flattened hierarchy has advantages of exposing the wrapped layer(s) to the optimizers. Backends may choose
to undo this after all optimizers have been applied on the wrapped layers.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.expand_time_distributed.ExpandTimeDistributed.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.fuse_biasadd">
<span id="hls4ml-model-optimizer-passes-fuse-biasadd-module"></span><h2>hls4ml.model.optimizer.passes.fuse_biasadd module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.fuse_biasadd" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.fuse_biasadd.</span></span><span class="sig-name descname"><span class="pre">FuseBiasAdd</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Fuses BiasAdd into Dense/Conv2D layer (common in TF models).</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.fuse_biasadd.FuseBiasAdd.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.hgq_proxy_model">
<span id="hls4ml-model-optimizer-passes-hgq-proxy-model-module"></span><h2>hls4ml.model.optimizer.passes.hgq_proxy_model module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.hgq_proxy_model" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">EnforceProxyModelEmbeddedConfig</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer" title="hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer"><span class="pre">FixedPointQuantizer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.EnforceProxyModelEmbeddedConfig.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">FixedPointQuantizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer.initialize" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">FuseFixedPointQuantizer</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><span class="pre">Layer</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.types.FixedPrecisionType" title="hls4ml.model.types.FixedPrecisionType"><span class="pre">FixedPrecisionType</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.propagate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><span class="pre">ModelGraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer" title="hls4ml.model.optimizer.passes.hgq_proxy_model.FixedPointQuantizer"><span class="pre">FixedPointQuantizer</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.FuseFixedPointQuantizer.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">UnaryLUT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attributes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initialize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Layer</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.UnaryLUT.initialize" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.register_hgq_proxy_model">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">register_hgq_proxy_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.register_hgq_proxy_model" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.hgq_proxy_model.userconf_ifdef">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.hgq_proxy_model.</span></span><span class="sig-name descname"><span class="pre">userconf_ifdef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.hgq_proxy_model.userconf_ifdef" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.infer_precision">
<span id="hls4ml-model-optimizer-passes-infer-precision-module"></span><h2>hls4ml.model.optimizer.passes.infer_precision module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.infer_precision" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.infer_precision.</span></span><span class="sig-name descname"><span class="pre">InferPrecisionTypes</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.ConfigurableOptimizerPass" title="hls4ml.model.optimizer.optimizer.ConfigurableOptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigurableOptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.infer_precision.InferPrecisionTypes.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.linear">
<span id="hls4ml-model-optimizer-passes-linear-module"></span><h2>hls4ml.model.optimizer.passes.linear module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.linear" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.EliminateLinearActivation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.linear.</span></span><span class="sig-name descname"><span class="pre">EliminateLinearActivation</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.EliminateLinearActivation" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.EliminateLinearActivation.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.EliminateLinearActivation.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.EliminateLinearActivation.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.EliminateLinearActivation.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.MergeLinearActivation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.linear.</span></span><span class="sig-name descname"><span class="pre">MergeLinearActivation</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.MergeLinearActivation" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>For many objects it’s safe to change the output precision independently of the calculation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.MergeLinearActivation.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.MergeLinearActivation.match" title="Link to this definition"></a></dt>
<dd><p>Only match if the parent is safe and the precision is not explicitly set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.linear.MergeLinearActivation.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.linear.MergeLinearActivation.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.matmul_const_to_dense">
<span id="hls4ml-model-optimizer-passes-matmul-const-to-dense-module"></span><h2>hls4ml.model.optimizer.passes.matmul_const_to_dense module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.matmul_const_to_dense" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.matmul_const_to_dense.</span></span><span class="sig-name descname"><span class="pre">MatmulConstToDense</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert MatMul with constant to a dense layer. Note, this only supports the second input
being the constant. If needed, one could add transposes to make that be the case in
other yet to be written optimizers.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.matmul_const_to_dense.MatmulConstToDense.transform" title="Link to this definition"></a></dt>
<dd><p>Substitute Matmul + Constant for a single dense</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.merge_const">
<span id="hls4ml-model-optimizer-passes-merge-const-module"></span><h2>hls4ml.model.optimizer.passes.merge_const module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.merge_const" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.merge_const.</span></span><span class="sig-name descname"><span class="pre">MergeToApplyAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert Add, Sub, Mul, or Div Merges with constant to ApplyAlpha</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.merge_const.</span></span><span class="sig-name descname"><span class="pre">MergeToApplyAlphaDiv</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert Div Merges with constant to ApplyAlpha</p>
<p>TODO:  propagate precision</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeToApplyAlphaDiv.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.merge_const.</span></span><span class="sig-name descname"><span class="pre">MergeTwoConstants</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Merge of two constants makes another constant</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.merge_const.MergeTwoConstants.transform" title="Link to this definition"></a></dt>
<dd><p>Merge of two constants makes another constant.</p>
<p>Note:  full precision is used in the calculation, and precision is not propagated.
The precision</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.move_scales">
<span id="hls4ml-model-optimizer-passes-move-scales-module"></span><h2>hls4ml.model.optimizer.passes.move_scales module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.move_scales" title="Link to this heading"></a></h2>
<p>This file includes optimizations related to moving the ApplyAphas across MatMul and Conv nodes.</p>
<p>TODO:  Check that biases are properly handled. (Attempt to do it via Merge)</p>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.BiasDownAdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.move_scales.</span></span><span class="sig-name descname"><span class="pre">BiasDownAdd</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.BiasDownAdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Shift a ApplyAlpha with only bias below a Merge (Add)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.BiasDownAdd.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.BiasDownAdd.match" title="Link to this definition"></a></dt>
<dd><p>Match if there is only one ApplyAlpha. If there are two, if the scale of both is 0, they would
match the ScaleDownAdd, so this optimizer does not need to handle that case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.BiasDownAdd.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.BiasDownAdd.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.move_scales.</span></span><span class="sig-name descname"><span class="pre">ScaleDownAdd</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Shift an identical ApplyAlpha below a Merge (Add)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd.match" title="Link to this definition"></a></dt>
<dd><p>Check to see if we have an add with two ApplyAlphas with identical scale</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownAdd.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownConv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.move_scales.</span></span><span class="sig-name descname"><span class="pre">ScaleDownConv</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownConv" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Shift an ApplyAlpha on a Conv with 2-3 inputs</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownConv.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownConv.match" title="Link to this definition"></a></dt>
<dd><p>Shift an ApplyAlpha from the Weight</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownConv.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownConv.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.move_scales.</span></span><span class="sig-name descname"><span class="pre">ScaleDownMatMul</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Shift an ApplyAlpha below a MatMul</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul.match" title="Link to this definition"></a></dt>
<dd><p>Check to see if we have a MatMul with at least one input ApplyAlpha.
Note, if both are this optimizer runs twice.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.move_scales.ScaleDownMatMul.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.multi_dense">
<span id="hls4ml-model-optimizer-passes-multi-dense-module"></span><h2>hls4ml.model.optimizer.passes.multi_dense module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.multi_dense" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.multi_dense.</span></span><span class="sig-name descname"><span class="pre">ReplaceMultidimensionalDenseWithConv</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This matches all multidimensional Dense layers and changes them to a convolution.
Note:  the convolution may subsequently be changed to a pointwise convolution for
bakends that implement special pointwise convolutions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.multi_dense.ReplaceMultidimensionalDenseWithConv.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.pad_const">
<span id="hls4ml-model-optimizer-passes-pad-const-module"></span><h2>hls4ml.model.optimizer.passes.pad_const module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.pad_const" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.pad_const.PaddingConstant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.pad_const.</span></span><span class="sig-name descname"><span class="pre">PaddingConstant</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.pad_const.PaddingConstant" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>ONNX has the padding come as an input, not a parameter. This removes the Constant node from the input.
The constant value was already used; this is just a cleanup uptimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.pad_const.PaddingConstant.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.pad_const.PaddingConstant.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.pad_const.PaddingConstant.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.pad_const.PaddingConstant.transform" title="Link to this definition"></a></dt>
<dd><p>Remove Constant node(s) from the graph. Note, padding is already present in ZeroPadding node.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.qkeras">
<span id="hls4ml-model-optimizer-passes-qkeras-module"></span><h2>hls4ml.model.optimizer.passes.qkeras module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.qkeras" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.qkeras.</span></span><span class="sig-name descname"><span class="pre">ExtractTernaryThreshold</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>The input value (threshold) at which the output of a a ternary activation
changes is configurable. This pass extracts that threshold point, inserting
a BatchNormalization layer to execute the scaling. That BatchNormalization
layer is then expected to be fused into a BatchNormalizationQuantizedTanh
layer configured with the correct threshold.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.ExtractTernaryThreshold.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.qkeras.</span></span><span class="sig-name descname"><span class="pre">OutputRoundingSaturationMode</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.ConfigurableOptimizerPass" title="hls4ml.model.optimizer.optimizer.ConfigurableOptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConfigurableOptimizerPass</span></code></a></p>
<p>Set the Rounding and Saturation mode of the output (and accumulator, if applicable)
of the layers specific in layer list.
The layer list is empty by default.
To specify which layer to apply this pass to, perform e.g.:
hls4ml.model.optimizer.get_optimizer(‘output_rounding_saturation_mode’).configure(layers=[‘Dense’, ‘Activation’])
The Rounding and Saturation modes are ‘None’ by default (so use the compiler defaults)
To set which mode to use:
hls4ml.model.optimizer.get_optimizer(‘output_rounding_saturation_mode’).configure(rounding_mode=’AP_RND_CONV’)
hls4ml.model.optimizer.get_optimizer(‘output_rounding_saturation_mode’).configure(saturation_mode=’AP_SAT’)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.precision_string_modify">
<span class="sig-name descname"><span class="pre">precision_string_modify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.precision_string_modify" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.OutputRoundingSaturationMode.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.qkeras.</span></span><span class="sig-name descname"><span class="pre">QKerasFactorizeAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>OptimizerPass for extracting alpha “scale” from QKeras quantized layer.
The weights of the Q{Dense, Conv} layer are scaled to the common data type,
and an ‘ApplyAlpha’ layer is inserted to reapply the scale.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.QKerasFactorizeAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.qkeras.register_qkeras">
<span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.qkeras.</span></span><span class="sig-name descname"><span class="pre">register_qkeras</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.qkeras.register_qkeras" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.quant_opt">
<span id="hls4ml-model-optimizer-passes-quant-opt-module"></span><h2>hls4ml.model.optimizer.passes.quant_opt module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.quant_opt" title="Link to this heading"></a></h2>
<p>This file includes optimizations related to quant nodes.</p>
<p>As a first step, QuantConstantParameters converts the extra inputs to attributes.</p>
<p>The next step differs between the case of (1) (positive) power-of-2 scale and zero offset, or (2) other cases. In the first
case no explicit scaling is required, so a Quant node logically becomes a linear activation. (Cases when the scale is a
power of 2 not equal to one are implicitly scaled with fixed precision types.) When the activation is applied to a constant
weight, the activation is immediately merged with the weight, quantizing the weights. In case (2), we need to explicitly
scale and unscale, so the Quant node becomes 3 nodes, an ApplyAlpha node to apply a scale/shift, a Linear node to apply the
quantization, and another ApplyAlpha to unscale/shift. We depend on optimization steps to move the unscaling ApplyAlpha
down as needed so that we can do integer or fixed-point calculations. When the Quant is a applied to a weight, the scaling
and Linear nodes are immediately merged into the Constant.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.quant_opt.</span></span><span class="sig-name descname"><span class="pre">ConstQuantToConstAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is not power-of-2 or zeropt is not 0. It is a a 1:3 transformation of
a Quant to an ApplyAlpha (to scale), Activation, ApplyAlpho (to unscale), but an input
consts allows for optimization, so the ApplyAlpha (to scale), Activation are
optimized away right away.</p>
<p>NOTE:  It needs to be scheduled after FuseQuantWithConstant (or we need to make the match criteria stricter)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.ConstQuantToConstAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Change Constant + Quant node to Constant, ApplyAlpha</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.quant_opt.</span></span><span class="sig-name descname"><span class="pre">FuseQuantWithConstant</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is a positive power of 2 and zeropt is 0, and when the input is a constant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.FuseQuantWithConstant.transform" title="Link to this definition"></a></dt>
<dd><p>Fuse Quant with Constant.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.quant_opt.</span></span><span class="sig-name descname"><span class="pre">QuantConstantParameters</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Remove Constant from the Qaunt node parameters (but not input[0])</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantConstantParameters.transform" title="Link to this definition"></a></dt>
<dd><p>Remove Constant from the Quant node parameters (but not input[0])</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToActivation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.quant_opt.</span></span><span class="sig-name descname"><span class="pre">QuantToActivation</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToActivation" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is a (positive) power of 2 and zeropt is 0. It is a a 1:1 transformation of
a Quant to an Activation.</p>
<p>This is not called when the input is constant.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToActivation.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToActivation.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToActivation.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToActivation.transform" title="Link to this definition"></a></dt>
<dd><p>Change quant node to Activation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.quant_opt.</span></span><span class="sig-name descname"><span class="pre">QuantToAlphaActivationAlpha</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This is for the case when scale is not power-of-2 or zeropt is not 0. It is a a 1:3 transformation of
a Quant to an ApplyAlpha (to scale), Activation, ApplyAlpho (to rescale).</p>
<p>NOTE:  It needs to be scheduled after QuantToActivation (or we need to make the match criteria stricter)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.quant_opt.QuantToAlphaActivationAlpha.transform" title="Link to this definition"></a></dt>
<dd><p>Change quant node to ApplyAlhpa, Activation, ApplyAlpha</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.reshape_const">
<span id="hls4ml-model-optimizer-passes-reshape-const-module"></span><h2>hls4ml.model.optimizer.passes.reshape_const module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.reshape_const" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.reshape_const.</span></span><span class="sig-name descname"><span class="pre">ReshapeConstant</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>ONNX has the target shape come as an input, not a parameter. This removes
the Constant input from new shape input. (Non-constant inputs are not supported.)
The constant value was already used; this is just a cleanup uptimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.reshape_const.ReshapeConstant.transform" title="Link to this definition"></a></dt>
<dd><p>Remove Constant from new shape input. Note, input shape node is already used on initialize</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.resize_remove_constants">
<span id="hls4ml-model-optimizer-passes-resize-remove-constants-module"></span><h2>hls4ml.model.optimizer.passes.resize_remove_constants module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.resize_remove_constants" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.resize_remove_constants.</span></span><span class="sig-name descname"><span class="pre">ResizeRemoveConstants</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>This optimizer is intended to clean the Resize node from RoI and Scales parameters that if left cause issues in hls4ml.</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.resize_remove_constants.ResizeRemoveConstants.transform" title="Link to this definition"></a></dt>
<dd><p>Remove RoI and Scale Constant from new shape input.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.seperable_to_dw_conv">
<span id="hls4ml-model-optimizer-passes-seperable-to-dw-conv-module"></span><h2>hls4ml.model.optimizer.passes.seperable_to_dw_conv module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.seperable_to_dw_conv" title="Link to this heading"></a></h2>
<p>This optimizer converts a separable convolution to a depthwise followed by a regular convolution.
For backends with a custom pointwise implementations the regular convolution will subsequently
be converted to a pointwise convolution by a different optimizer.</p>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.seperable_to_dw_conv.</span></span><span class="sig-name descname"><span class="pre">SeparableToDepthwiseAndConv</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Convert Separable to DepthwiseConv + Conv (potentially later Pointwise)</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.seperable_to_dw_conv.SeparableToDepthwiseAndConv.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.stamp">
<span id="hls4ml-model-optimizer-passes-stamp-module"></span><h2>hls4ml.model.optimizer.passes.stamp module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.stamp" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.stamp.MakeStamp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.stamp.</span></span><span class="sig-name descname"><span class="pre">MakeStamp</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.stamp.MakeStamp" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.ModelOptimizerPass" title="hls4ml.model.optimizer.optimizer.ModelOptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModelOptimizerPass</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.stamp.MakeStamp.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.stamp.MakeStamp.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes.transpose_opt">
<span id="hls4ml-model-optimizer-passes-transpose-opt-module"></span><h2>hls4ml.model.optimizer.passes.transpose_opt module<a class="headerlink" href="#module-hls4ml.model.optimizer.passes.transpose_opt" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.transpose_opt.</span></span><span class="sig-name descname"><span class="pre">RemoveNopTranspose</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Remove a transpose layer if it doesn’t do anything to a 1D array. i.e, 1D input and perm = [0]</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveNopTranspose.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">hls4ml.model.optimizer.passes.transpose_opt.</span></span><span class="sig-name descname"><span class="pre">RemoveSingleChannelTranspose</span></span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="hls4ml.model.optimizer.html#hls4ml.model.optimizer.optimizer.OptimizerPass" title="hls4ml.model.optimizer.optimizer.OptimizerPass"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizerPass</span></code></a></p>
<p>Remove transpose of inputs if the number of channels is 1 as for io_parallel this doesn’t affect the array
representation used</p>
<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose.match" title="Link to this definition"></a></dt>
<dd><p>Predicate to match on a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – Node in the model graph to try matching the optimizer on.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hls4ml.model.optimizer.passes.transpose_opt.RemoveSingleChannelTranspose.transform" title="Link to this definition"></a></dt>
<dd><p>Transformation to apply if matching was successful.</p>
<p>Transform should return a boolean value indicating if the model graph was altered (by adding/removing nodes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.graph.ModelGraph" title="hls4ml.model.graph.ModelGraph"><em>ModelGraph</em></a>) – Model to optimize</p></li>
<li><p><strong>node</strong> (<a class="reference internal" href="hls4ml.model.html#hls4ml.model.layers.Layer" title="hls4ml.model.layers.Layer"><em>Layer</em></a>) – The matched node in the model graph.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-hls4ml.model.optimizer.passes">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-hls4ml.model.optimizer.passes" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="hls4ml.model.optimizer.html" class="btn btn-neutral float-left" title="hls4ml.model.optimizer package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="hls4ml.optimization.html" class="btn btn-neutral float-right" title="hls4ml.optimization package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Fast Machine Learning Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>